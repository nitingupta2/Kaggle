{
    "collab_server" : "",
    "contents" : "\nlibrary(Matrix)\nlibrary(magrittr)\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(xgboost)\n\nSEED <- 2016\nID_VAR <- \"USER_ID\"\nTARGET_VAR <- \"Party\"\n\ndfQuestions <- read_delim(\"questions.tsv\", delim = \"\\t\") %>% set_colnames(c(\"ID\", \"QnA\"))\ndfQuestions$ID <- paste0(\"Q\", dfQuestions$ID)\n\ndfRawTrain <- read_csv(\"train2016.csv\", na = c(\"\", NA))\ndfRawTest <- read_csv(\"test2016.csv\", na = c(\"\", NA))\ndfRawTest[[TARGET_VAR]] <- NA\n\nnames(dfRawTrain)\nvFeaturesDemographic <- c(\"YOB\", \"Gender\", \"Income\", \"HouseholdStatus\", \"EducationLevel\")\nvFeaturesSurveyQues <- names(dfRawTrain)[!(names(dfRawTrain) %in% vFeaturesDemographic)]\n# exclude USER_ID from survey questions\nvFeaturesSurveyQues <- vFeaturesSurveyQues[!(vFeaturesSurveyQues %in% c(ID_VAR, TARGET_VAR))]\n\n# Pre-process data - First way\n########################################################################################################################\npreProcess1 <- function(dfMerged) {\n    # Set median age in missing and outlier values\n    medianYOB <- median(dfMerged$YOB, na.rm = T)\n    dfMerged <- dfMerged %>% \n        mutate(YOB = ifelse(is.na(YOB) | YOB <= 1930 | YOB >= 2003, medianYOB, YOB))\n    \n    # Assign 'dnr' to unanswered survey questions and convert to factors\n    dfMerged[vFeaturesSurveyQues] <- lapply(dfMerged[vFeaturesSurveyQues], as.character)\n    dfMerged[vFeaturesSurveyQues][is.na(dfMerged[vFeaturesSurveyQues])] <- \"dnr\"\n    dfMerged[vFeaturesSurveyQues] <- lapply(dfMerged[vFeaturesSurveyQues], as.factor)\n    dfMerged[vFeaturesSurveyQues] <- lapply(dfMerged[vFeaturesSurveyQues], relevel, \"dnr\")\n    \n    # Set the maximum factor level where NA\n    for(feature in vFeaturesDemographic) {\n        if(class(dfMerged[[feature]]) == \"character\") {\n            dfMerged[[feature]][is.na(dfMerged[[feature]])] <- names(which.max(table(dfMerged[[feature]])))\n            dfMerged[[feature]] <- as.factor(dfMerged[[feature]])\n        }\n    }\n    \n    return(dfMerged)\n}\n\n# Pre-process data - Second way\n########################################################################################################################\npreProcess2 <- function(dfMerged) {\n    # Since many respondents have not provided demographic and survey questions, # of valid responses need to be recorded\n    dfMerged$NumSurveyAns <- apply(dfMerged[vFeaturesSurveyQues], 1, function(Z) sum(!is.na(Z)))\n    \n    # Set median age in missing and outlier values\n    medianYOB <- median(dfMerged$YOB, na.rm = T)\n    dfMerged <- dfMerged %>% \n        mutate(YOB = ifelse(is.na(YOB) | YOB <= 1930 | YOB >= 2003, medianYOB, YOB))\n    \n    # Assign 'dnr' to unanswered survey questions and convert to factors\n    dfMerged[vFeaturesSurveyQues] <- lapply(dfMerged[vFeaturesSurveyQues], as.character)\n    dfMerged[vFeaturesSurveyQues][is.na(dfMerged[vFeaturesSurveyQues])] <- \"dnr\"\n    dfMerged[vFeaturesSurveyQues] <- lapply(dfMerged[vFeaturesSurveyQues], as.factor)\n    dfMerged[vFeaturesSurveyQues] <- lapply(dfMerged[vFeaturesSurveyQues], relevel, \"dnr\")\n    \n    # Set 'dnr' to factor level where NA\n    for(feature in vFeaturesDemographic) {\n        if(class(dfMerged[[feature]]) == \"character\") {\n            dfMerged[[feature]][is.na(dfMerged[[feature]])] <- \"dnr\"\n            dfMerged[[feature]] <- as.factor(dfMerged[[feature]])\n            dfMerged[[feature]] <- relevel(dfMerged[[feature]], \"dnr\")\n        }\n    }\n    \n    return(dfMerged)\n}\n\n# Pre-process data - Third way\n#########################################################################################################################\npreProcess3 <- function(dfMerged) {\n    # Since many respondents have not provided demographic and survey questions, # of valid responses need to be recorded\n    dfMerged$NumSurveyAns <- apply(dfMerged[vFeaturesSurveyQues], 1, function(Z) sum(!is.na(Z)))\n    \n    # Set median age in missing and outlier values\n    medianYOB <- median(dfMerged$YOB, na.rm = T)\n    dfMerged <- dfMerged %>% \n        mutate(YOB = ifelse(is.na(YOB) | YOB <= 1930 | YOB >= 2003, medianYOB, YOB))\n    \n    # Assign 'dnr' to unanswered survey questions and convert to factors\n    dfMerged[vFeaturesSurveyQues] <- lapply(dfMerged[vFeaturesSurveyQues], as.character)\n    dfMerged[vFeaturesSurveyQues][is.na(dfMerged[vFeaturesSurveyQues])] <- \"dnr\"\n    dfMerged[vFeaturesSurveyQues] <- lapply(dfMerged[vFeaturesSurveyQues], as.factor)\n    dfMerged[vFeaturesSurveyQues] <- lapply(dfMerged[vFeaturesSurveyQues], relevel, \"dnr\")\n    \n    # Set 'dnr' to factor level where NA\n    for(feature in vFeaturesDemographic) {\n        if(class(dfMerged[[feature]]) == \"character\") {\n            dfMerged[[feature]][is.na(dfMerged[[feature]])] <- \"dnr\"\n            dfMerged[[feature]] <- as.factor(dfMerged[[feature]])\n            dfMerged[[feature]] <- relevel(dfMerged[[feature]], \"dnr\")\n        }\n    }\n    \n    # With chisq goodness of fit determine survey questions whose probability distribution \n    # is very different from Party distribution in the data set\n    dfXsq <- data.frame()\n    indexTarget <- which(names(dfMerged) == TARGET_VAR)\n    for(i in seq_along(vFeaturesSurveyQues)) {\n        indexQ <- which(names(dfMerged) == vFeaturesSurveyQues[i])\n        tbl <- table(unlist(dfMerged[,indexTarget]), unlist(dfMerged[,indexQ]))\n        Xsq <- chisq.test(tbl)\n        dfXsq <- rbind(dfXsq, data.frame(surveyQues = vFeaturesSurveyQues[i], pvalue = Xsq$p.value))\n    }\n    chisq_threshold_pvalue <- 0.05\n    dfXsq <- dfXsq %>% dplyr::filter(pvalue < chisq_threshold_pvalue) %>% arrange(pvalue)\n    vFeaturesSurveyInterest <- as.character(dfXsq$surveyQues)\n    \n    # reduce survey questions in the final data set\n    return(dfMerged[c(ID_VAR, TARGET_VAR, \"NumSurveyAns\", vFeaturesDemographic, vFeaturesSurveyInterest)])\n}\n\n# Pre-process data - Fourth & Fifth way\n#########################################################################################################################\npreProcess4 <- function(dfMerged, chisq_threshold_pvalue = 0.05) {\n    # Since many respondents have not provided demographic and survey questions, # of valid responses need to be recorded\n    dfMerged$NumSurveyAns <- apply(dfMerged[vFeaturesSurveyQues], 1, function(Z) sum(!is.na(Z)))\n    \n    # Set median age in missing and outlier values\n    medianYOB <- median(dfMerged$YOB, na.rm = T)\n    dfMerged <- dfMerged %>% \n        mutate(YOB = ifelse(is.na(YOB) | YOB <= 1930 | YOB >= 2003, medianYOB, YOB)) %>% \n        mutate(Age = 2016 - YOB) %>% \n        mutate(Age_group = cut(Age, c(0, 18, 44, 64, 90)))\n    \n    # Assign 'dnr' to unanswered survey questions and convert to factors\n    dfMerged[vFeaturesSurveyQues] <- lapply(dfMerged[vFeaturesSurveyQues], as.character)\n    dfMerged[vFeaturesSurveyQues][is.na(dfMerged[vFeaturesSurveyQues])] <- \"dnr\"\n    dfMerged[vFeaturesSurveyQues] <- lapply(dfMerged[vFeaturesSurveyQues], as.factor)\n    dfMerged[vFeaturesSurveyQues] <- lapply(dfMerged[vFeaturesSurveyQues], relevel, \"dnr\")\n    \n    # Set 'dnr' to factor level where NA\n    for(feature in vFeaturesDemographic) {\n        if(class(dfMerged[[feature]]) == \"character\") {\n            dfMerged[[feature]][is.na(dfMerged[[feature]])] <- \"dnr\"\n            dfMerged[[feature]] <- as.factor(dfMerged[[feature]])\n            dfMerged[[feature]] <- relevel(dfMerged[[feature]], \"dnr\")\n        }\n    }\n    \n    # With chisq goodness of fit determine survey questions whose probability distribution \n    # is very different from Party distribution in the data set\n    dfXsq <- data.frame()\n    indexTarget <- which(names(dfMerged) == TARGET_VAR)\n    for(i in seq_along(vFeaturesSurveyQues)) {\n        indexQ <- which(names(dfMerged) == vFeaturesSurveyQues[i])\n        tbl <- table(unlist(dfMerged[,indexTarget]), unlist(dfMerged[,indexQ]))\n        Xsq <- chisq.test(tbl)\n        dfXsq <- rbind(dfXsq, data.frame(surveyQues = vFeaturesSurveyQues[i], pvalue = Xsq$p.value))\n    }\n    dfXsq <- dfXsq %>% dplyr::filter(pvalue < chisq_threshold_pvalue) %>% arrange(pvalue)\n    vFeaturesSurveyInterest <- as.character(dfXsq$surveyQues)\n    \n    # reduce survey questions in the final data set\n    dfMerged <- dfMerged[c(ID_VAR, TARGET_VAR, \"Age_group\", \"NumSurveyAns\", vFeaturesDemographic, vFeaturesSurveyInterest)]\n    dfMerged <- dfMerged %>% select(-YOB)\n    return(dfMerged)\n}\n\n# Pre-process data - Sixth & Seventh way\n#########################################################################################################################\npreProcess6 <- function(dfMerged, chisq_threshold_pvalue = 0.05) {\n    # Since many respondents have not provided demographic and survey questions, # of valid responses need to be recorded\n    dfMerged$NumSurveyAns <- apply(dfMerged[vFeaturesSurveyQues], 1, function(Z) sum(!is.na(Z)))\n    \n    # Set median age in missing and outlier values\n    medianYOB <- median(dfMerged$YOB, na.rm = T)\n    dfMerged <- dfMerged %>% \n        mutate(YOB = ifelse(is.na(YOB) | YOB <= 1930 | YOB >= 2003, medianYOB, YOB)) %>% \n        mutate(Age = 2016 - YOB) %>% \n        mutate(Age_group = cut(Age, c(0, 18, 44, 64, 90)))\n    \n    # With chisq goodness of fit determine survey questions whose probability distribution \n    # is very different from Party distribution in the data set\n    dfXsq <- data.frame()\n    for(surveyQues in vFeaturesSurveyQues) {\n        tbl <- table(unlist(dfMerged[[TARGET_VAR]]), unlist(dfMerged[[surveyQues]]))\n        Xsq <- chisq.test(tbl)\n        dfXsq <- rbind(dfXsq, data.frame(surveyQues = surveyQues, pvalue = Xsq$p.value))\n    }\n    dfXsq <- dfXsq %>% dplyr::filter(pvalue < chisq_threshold_pvalue) %>% arrange(pvalue)\n    vFeaturesSurveyInterest <- as.character(dfXsq$surveyQues)\n    \n    # Valid responses to interesting questions\n    dfMerged$NumSurveyAnsInterest <- apply(dfMerged[vFeaturesSurveyInterest], 1, function(Z) sum(!is.na(Z)))\n    \n    # Assign 'dnr' to unanswered survey questions and convert to factors\n    dfMerged[vFeaturesSurveyQues] <- lapply(dfMerged[vFeaturesSurveyQues], as.character)\n    dfMerged[vFeaturesSurveyQues][is.na(dfMerged[vFeaturesSurveyQues])] <- \"dnr\"\n    dfMerged[vFeaturesSurveyQues] <- lapply(dfMerged[vFeaturesSurveyQues], as.factor)\n    dfMerged[vFeaturesSurveyQues] <- lapply(dfMerged[vFeaturesSurveyQues], relevel, \"dnr\")\n    \n    # Set 'dnr' to factor level where NA\n    for(feature in vFeaturesDemographic) {\n        if(class(dfMerged[[feature]]) == \"character\") {\n            dfMerged[[feature]][is.na(dfMerged[[feature]])] <- \"dnr\"\n            dfMerged[[feature]] <- as.factor(dfMerged[[feature]])\n            dfMerged[[feature]] <- relevel(dfMerged[[feature]], \"dnr\")\n        }\n    }\n    \n    # Create a feature 'IsLiberal' from the answers to the survey questions of interest\n    dfMerged <- dfMerged %>% \n        mutate(IsLiberal = case_when(.$Q109244 == \"Yes\" ~ \"Yes\",\n                                     .$Q115611 == \"Yes\" ~ \"No\",\n                                     .$Q113181 == \"Yes\" ~ \"No\",\n                                     .$Q113181 == \"No\" & .$Q115611 == \"No\" & .$Q109244 == \"No\" ~ \"Yes\")) %>% \n        mutate(IsLiberal = ifelse(is.na(IsLiberal), \"unknown\", IsLiberal))\n                                     \n    # reduce survey questions in the final data set\n    dfMerged <- dfMerged[c(ID_VAR, TARGET_VAR, \"Age_group\", \"NumSurveyAnsInterest\", \"IsLiberal\",\n                           vFeaturesDemographic, vFeaturesSurveyInterest)]\n    dfMerged <- dfMerged %>% select(-YOB)\n    return(dfMerged)\n}\n\n########################################################################################################################\n# Select Preprocessing function\n########################################################################################################################\n\n# Combine raw training and test sets\ndfMerged <- rbind(dfRawTrain, dfRawTest)\nsummary(dfMerged)\n\npreProcessFuncName <- \"preProcess7\"\n\nif(preProcessFuncName == \"preProcess1\") {\n    dfMerged <- preProcess1(dfMerged)\n} else if(preProcessFuncName == \"preProcess2\") {\n    dfMerged <- preProcess2(dfMerged)\n} else if(preProcessFuncName == \"preProcess3\") {\n    dfMerged <- preProcess3(dfMerged)\n} else if(preProcessFuncName == \"preProcess4\") {\n    dfMerged <- preProcess4(dfMerged)\n} else if(preProcessFuncName == \"preProcess5\") {\n    dfMerged <- preProcess4(dfMerged, chisq_threshold_pvalue = 0.001)\n} else if(preProcessFuncName == \"preProcess6\") {\n    dfMerged <- preProcess6(dfMerged, chisq_threshold_pvalue = 0.001)\n} else if(preProcessFuncName == \"preProcess7\") {\n    dfMerged <- preProcess6(dfMerged, chisq_threshold_pvalue = 0.05)\n}\n\nnames(dfMerged)\ntable(dfMerged$IsLiberal, dfMerged$Party)\n\n# Split merged data into final training and test sets\ndfTrain <- dfMerged %>% subset(!is.na(get(TARGET_VAR)))\ndfTest <- dfMerged %>% subset(is.na(get(TARGET_VAR))) \ndfTest[[TARGET_VAR]] <- \"dummy\"\n\n# Write preprocessed data to file\nwrite.table(dfTrain, file = paste0(\"train_\", preProcessFuncName, \".tsv\"), row.names = F, sep = \"\\t\")\nwrite.table(dfTest, file = paste0(\"test_\", preProcessFuncName, \".tsv\"), row.names = F, sep = \"\\t\")\n\n########################################################################################################################\n# Parameter tuning by 10 fold CV\n########################################################################################################################\n\ncvFileName <- paste0(\"cv_xgboost_\", preProcessFuncName , \".csv\")\n\nsmm_train <- sparse.model.matrix(Party ~ . -1, data = dfTrain %>% select(-starts_with(ID_VAR)))\nsmm_test <- sparse.model.matrix(Party ~ . -1, data = dfTest %>% select(-starts_with(ID_VAR)))\ny_train <- as.integer(as.factor(dfTrain[[TARGET_VAR]])) - 1\nx_train <- xgb.DMatrix(data = smm_train, label = y_train)\n\ncustom_eval_func <- function (yhat, x_train) {\n    y = getinfo(x_train, \"label\")\n    y_pred = as.integer(yhat > 0.5)\n    err= ModelMetrics::auc(y, y_pred)\n    return (list(metric = \"auc\", value = err))\n}\n\n# Parameter tuning\ndef_eta <- 0.3\ndef_max_depth <- 1\ndef_min_child_weight <- 1\ndef_gamma <- 0\ndef_subsample <- 1\ndef_colsample_bytree <- 1\ndef_alpha <- 0\n\ndfParams <- expand.grid(eta=seq(0.3,0.5,0.1), max_depth=c(1:3), min_child_weight=100,\n                        gamma=1, subsample=seq(0.6,1,0.1), colsample_bytree=seq(0.5,0.9,0.1), \n                        alpha=1)\nprint(dfParams)\n\nfor(i in 1:nrow(dfParams)) {\n    print(paste(\"Tuning parameter combination\", i, \"of\", nrow(dfParams)))\n    \n    eta = dfParams$eta[i]\n    max_depth = dfParams$max_depth[i]\n    min_child_weight = dfParams$min_child_weight[i]\n    gamma = dfParams$gamma[i]\n    subsample = dfParams$subsample[i]\n    colsample_bytree = dfParams$colsample_bytree[i]\n    alpha = dfParams$alpha[i]\n    \n    xgb_params = list(\n        colsample_bytree = colsample_bytree,\n        subsample = subsample,\n        eta = eta,\n        max_depth = max_depth,\n        min_child_weight = min_child_weight,\n        alpha = alpha,\n        gamma = gamma,\n        nthreads = 4\n    )\n    \n    start_time <- Sys.time()\n    \n    set.seed(SEED)\n    cv_res <- xgb.cv(xgb_params,\n                     x_train,\n                     nrounds=15000,\n                     nfold=10,\n                     early_stopping_rounds=150,\n                     print_every_n = 50,\n                     verbose= 1,\n                     feval = custom_eval_func,\n                     objective = \"binary:logistic\",\n                     maximize=TRUE)\n    \n    best_nrounds <- cv_res$best_iteration\n    cv_mean <- cv_res$evaluation_log$test_auc_mean[best_nrounds]\n    cv_std <- cv_res$evaluation_log$test_auc_std[best_nrounds]\n    \n    end_time <- Sys.time()\n    min_taken <- as.numeric(difftime(end_time, start_time, units = \"mins\"))\n    \n    dfCV <- data.frame(cv_mean = formatC(cv_mean, digits = 5, drop0trailing = F), \n                       cv_std = formatC(cv_std, digits = 5, drop0trailing = F), \n                       min_taken=formatC(min_taken, digits = 5, drop0trailing = F),\n                       best_iteration=best_nrounds, eta=eta, max_depth=max_depth, min_child_weight=min_child_weight,\n                       gamma=gamma, subsample=subsample, colsample_bytree=colsample_bytree,\n                       alpha=alpha)\n    \n    write.table(dfCV, file = cvFileName, col.names = (i == 1 & !file.exists(cvFileName)), \n                row.names = F, quote = F, append = T, sep = \"\\t\")\n}\n\n# Show best CV values\ndfCV <- read.table(file = cvFileName, header = T)\nprint(tail(dfCV %>% arrange(cv_mean)))\n\n# Write sorted CV data back to file\nwrite.table(dfCV %>% arrange(desc(cv_mean)), file = cvFileName, row.names = F, quote = F, sep = \"\\t\")\n",
    "created" : 1482509227994.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "348543224",
    "id" : "59D5512C",
    "lastKnownWriteTime" : 1482908064,
    "last_content_update" : 1482908064965,
    "path" : "C:/Backups/Kaggle/VotersParty/model_xgboost_tune.R",
    "project_path" : "model_xgboost_tune.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}